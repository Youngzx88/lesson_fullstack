# 第三章 函数作用域和块作用域

## 3.1、函数中的作用域
## 3.2、隐藏内部实现
- 最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计
- 如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小
特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的
> 作用:规避冲突
- “隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖
```javascript
function foo() {
    function bar(a) {
        i = 3; // 修改 for 循环所属作用域中的 i
        console.log( a + i );
    }
    for (var i=0; i<10; i++) {
        bar( i * 2 ); // 糟糕，无限循环了！
    }
}
foo();
```
1. 方式一:全局命名空间
2. 方式二:模块管理（第五章）

## 3.3、函数作用域
- 我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容
- 如果函数不需要函数名（或者至少函数名可以不污染所在作用域;例如全局），并且能够自动运行，这将会更加理想
```javascript
(function foo(){ // <-- 添加这一行
    var a = 3;
    console.log( a ); // 3
})(); // <-- 以及这一行

console.log( a ); // 2  
```
- 首先，包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理，避免全局变量意外事故
```javascript
// 函数表达式
let sayHi = function(){
    alter("hello");
}
// 函数声明
function sayHi(){
    alter("hello");
};
```
- 函数表达式:是在代码执行到达时被创建，并且仅从那一刻起可用。
- 函数声明则不同:在函数声明被定义之前，它就可以被调用。

### 3.3.1、匿名和具名
```javascript
// 常见的匿名函数
setTimeout( function() {
    console.log("I waited 1 second!");
}, 1000 )
```
- 匿名函数的缺点
    - 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
    - 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身
    - 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明

- 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。
```javascript
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
    console.log( "I waited 1 second!" );
}, 1000 )
```

### 3.3.1、立即执行函数表达式（IIFE）
```javascript
var a = 2;
(function foo() {
    var a = 3;
    console.log( a ); // 3
})();
console.log( a ); // 2
```
- 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数
- 函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践

**进阶用法**
- 是把它们当作函数调用并传递参数进去
- 我们将 window 对象的引用传递进去，但将参数命名global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。
```javascript
var a = 2;
(function IIFE( global ) {
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );
console.log( a ); // 2
```

## 3.4、块作用域
- 除 JavaScript 外的很多编程语言都支持块作用域，因此其他语言的开发者对于相关的思维方式会很熟悉，但是对于主要使用 JavaScript 的开发者来说，这个概念会很陌生。

### 3.4.1、with
- 是块作用域的一个例子（块作用域的一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效

### 3.4.2、try/catch
```javascript
try {
    undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
    console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```
- try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效
- 仅存在 catch 分句内部的变量，当试图从别处引用它时会抛出错误。

- **ps**：尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境（除了老版本的 IE 浏览器）所支持，但是当同一个作用域中的两个或多个 catch 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出警告。为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查

### 3.4.3、let
- let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let为其声明的变量隐式地了所在的块作用域
```javascript
//正常写法
var foo = true;

if (foo) {
    let bar = foo * 2;
    bar = something( bar );
    console.log( bar );
}
console.log( bar ); // ReferenceError
```
```javascript
//更好的写法
var foo = true;
if (foo) {
    { // <-- 显式的快
    let bar = foo * 2;
    bar = something( bar );
    console.log( bar );
    }
}
console.log( bar ); // ReferenceError
```
> 作用
1. 为变量显式声明块作用域，有利于垃圾回收
2. let循环(不会命名冲突导致死循环)

### 3.4.3、const
- ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误


## 3.5、小结
- 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则
- 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，
也可以属于某个代码块（通常指 { .. } 内部）。