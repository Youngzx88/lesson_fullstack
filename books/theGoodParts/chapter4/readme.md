# 4.函数

## 4.1、函数对象
- js中函数就是一种对象
- 函数在创建时有两个隐藏属性
    - 函数上下文
    - 实现函数行为的代码
- 函数可以存放变量,对象,数组

## 4.2、函数字面量
```javascript
var add =function (a, b){
    return a + b;
};

```
- 组成
    1. function
    2. 函数名
    3. ()中的参数
    4. {}中的语句

## 4.3、调用
**每个函数接收两个附加的参数:this 和 arguments**
- this的使用取决与当前的调用模式
    1. 方法调用模式
        - 当一个函数被保存为对象的一个属性时，我们称它为一个方法。
        - 当一个方法被调用,this被绑定到该对象。如果一个调用表达式包含一个属性存取表达式，那么它被当作一个方法来调用。
        ```javascript
        var myObject = {
        value: 0;
        increment: function (inc) {
        this.value +=typeof ine === ' number'? inc : 1;
        };
        ```
    2. 函数调用模式
        - 当一个函数并非一个对象的属性时，那么它被当作一个函数来调用
        - 当函数以此模式调用时，this被绑定到全局对象。这是语言设计上的一个错误。
        ```javascript
        var sum = add(3,4);
        ```
    3. 构造器调用模式
        - javascript基于原型继承,但也提供了一套基于类的对象构建语法
        - 如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象,同时this将会被绑定到那个新对象上。
    4. apply调用模式
        - 因为JavaScript是一门函数式的面向对象编程语言，所以函数可以拥有方法。
        - apply方法让我们构建一个参数数组并用其去调用函数。它也允许我们选择this 的值apply方法接收两个参数。第一个是将被绑定给this的值。第二个就是一个参数数组。
        - apply的第一个参数可以显示的控制this的指向
        ```javascript   
        var array =[3,4];
        var sum = add.apply(null,array) ;// sum值为7
        ```

## 4.4、参数
- 当函数被调用时，会得到一个“免费”奉送的参数，那就是arguments 数组。通过它函数可以访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。
- 但是这实际上是语言的一个设计错误，arguments并不是一个真正的数组。它只是一个“类似数组(array-like)”的对象。arguments拥有一个length 属性，但它缺少所有的数组方法。


## 4.5、返回
- 当一个函数被调用时，它从第一个语句开始执行，并在遇到关闭函数体的）时结束。那使得函数把控制权交还给调用该函数的程序部分。
- return语句可用来使函数提前返回。当return被执行时，函数立即返回而不再执行余下的语句。
- 一个函数总是会返回一个值。如果没有指定返回值，则返回undefined 。
- 如果函数以在前面加上 new前缀的方式来调用,且.返回值不是一个对象,则返回 this (该新对象)。

## 4.6、异常
和java类似 try catch 抛出异常

## 4.7、给类型增加方法
- JavaScript允许给语言的基本类型增加方法。
- 举例来说，我们可以通过给Function.prototype增加方法来使得该方法对所有函数可用
```javascript
Function.prototype.method = function (name,func){
    this.prototype [name] = func;
    return this;
};
```

## 4.8、递归
略

## 4.9、作用域
- 尽管代码块的语法似乎表现出它支持块级作用域,但实际上JavaScript并不支持。
- JavaScript确实有函数作用域。那意味着定义在函数中的参数和变量在函数外部是不可见的，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都可见。
- 很多现代语言都推荐尽可能迟地声明变量。而用在JavaScript 上的话却会成为糟糕的建议，因为它缺少块级作用域。所以，最好的做法是在函数体的顶部声明函数中可能用到的所有变量。

**解决方式：**
- es6中的let是局部作用域
- 建议大家都是用let去定义局部作用域的变量;

