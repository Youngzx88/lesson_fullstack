# 继承

## 伪类模式(函数创建类)
- 当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码
```javascript
this.prototype = {constructor: this};
```
- 新函数对象被赋予一个 prototype属性，其值是包含一个constructor属性且属性值为该新函数对象。该prototype对象是存放继承特征的地方。因为JavaScript语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个 prototype对象。constructor属性没什么用。重要的是prototype对象。
- 使用构造器函数存在一个严重的危害。如果你在调用构造器函数时忘记了在前面加上new前缀，那么this将不会被绑定到一个新对象上。可悲的是，this将被绑定到全局对象上，所以你不但没有扩充新对象，反而将破坏全局变量。那真是糟透了。发生那样的情况时,既没有编译时警告，也没有运行时警告。

## 对象说明符
- 有时候，构造器要接受一大串的参数。这可能是令人烦恼的，因为要记住参数的顺序可能非常困难。在这种情况下，如果我们在编写构造器时使其接受一个简单的对象说明符可能会更加友好。那个对象包含了将要构建的对象规格说明。所以，与其这样写:
```javascript
var myobject = maker(f,l, m,c, s) ;
```
不如这么写:
```javascript
var myObject = maker({
    first: f,
    last: l,
    state: s,
    city: c
});
```

## 原型
- 在一个纯粹的原型模式中，我们会摒弃类，转而专注于对象。基于原型的继承相比基于类的继承在概念上更为简单:一个新对象可以继承一个旧对象的属性。也许你对此感到陌生，但它真的很容易理解。你通过构造一个有用的对象开始，接着可以构造更多和那个对象类似的对象。可以完全避免把一个应用拆解成一系列嵌套抽象类的分类过程。
1. 先用对象字面量创建一个对象
2. 一旦有了一个想要的对象,就可以用自定义的Object.beget方法构造出更多实例来

## 函数化

