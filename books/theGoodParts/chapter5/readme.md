# 继承

## 1、伪类模式(函数创建类)
- 当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码
```javascript
this.prototype = {constructor: this};
```
- 新函数对象被赋予一个 prototype属性，其值是包含一个constructor属性且属性值为该新函数对象。该prototype对象是存放继承特征的地方。因为JavaScript语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个 prototype对象。constructor属性没什么用。重要的是prototype对象。
- 使用构造器函数存在一个严重的危害。如果你在调用构造器函数时忘记了在前面加上new前缀，那么this将不会被绑定到一个新对象上。可悲的是，this将被绑定到全局对象上，所以你不但没有扩充新对象，反而将破坏全局变量。那真是糟透了。发生那样的情况时,既没有编译时警告，也没有运行时警告。

## 2、对象说明符
- 有时候，构造器要接受一大串的参数。这可能是令人烦恼的，因为要记住参数的顺序可能非常困难。在这种情况下，如果我们在编写构造器时使其接受一个简单的对象说明符可能会更加友好。那个对象包含了将要构建的对象规格说明。所以，与其这样写:
```javascript
var myobject = maker(f,l, m,c, s) ;
```
不如这么写:
```javascript
var myObject = maker({
    first: f,
    last: l,
    state: s,
    city: c
});
```
- 
## 3、原型
- 在一个纯粹的原型模式中，我们会摒弃类，转而专注于对象。基于原型的继承相比基于类的继承在概念上更为简单:一个新对象可以继承一个旧对象的属性。也许你对此感到陌生，但它真的很容易理解。你通过构造一个有用的对象开始，接着可以构造更多和那个对象类似的对象。可以完全避免把一个应用拆解成一系列嵌套抽象类的分类过程。
1. 先用对象字面量创建一个对象
2. 一旦有了一个想要的对象,就可以用自定义的Object.beget方法构造出更多实例来
```javascript
var myMammal ={
    name:"Herb the Mamnal",
    get_name : function (){
        return this. name;
),
    says : funetion {
        return this .saying || '';
    )
};
```
## 4、函数化
- 迄今为止，所看到的继承模式的一个弱点就是我们没法保护隐私。对象的所有属性都是可见的。我们没法得到私有变量和私有函数。有时候那不要紧，但有时候却是大麻烦。
- 我们有一个更好的选择，那就是模块模式的应用。
```javascript
var constructor = function (spec, my) {
    var that,其他的私有实例变量;
    my = my || {);
    把共享的变量和函数添加到my中
    that =一个新对象
    添加给that的特权方法
    return that;
)
```
- 函数化模式有很大的灵活性。它不仅不像伪类模式那样需要很多功夫，还让我们得到更好的封装和信息隐藏，以及访问父类方法的能力。
- 如果对象的所有状态都是私有的，那么该对象就成为一个“防伪(tamper-proof)”对象。该对象的属性可以被替换或删除，但该对象的完整性不会受到损害。如果我们用函数化的样式创建一个对象，并且该对象的所有方法都不使用this或that，那么该对象就是持久性的。一个持久性对象就是一个简单功能函数的集合。
- 一个持久性的对象不会被损害。访问一个持久性的对象时，除非被方法授权，否则攻击者不能访问对象的内部状态。

## 5、部件
- 我们可以从一套部件中组合出对象来。例如，我们可以构造一个能添加简单事件处理特性到任何对象上的函数。它会给对象添加一个on方法、一个 fire方法和一个私有的事件注册表对象:
- 我们可以在任何单独的对象上调用eventuality，授予它事件处理方法。我们也可以赶在that被返回前在一个构造器函数中调用它。
- 用这种方式，一个构造器函数可以从一套部件中组装出对象来。JavaScript 的弱类型在此处是一个巨大的优势，因为我们无须花费精力去关注一个类型系统中的类谱系。
