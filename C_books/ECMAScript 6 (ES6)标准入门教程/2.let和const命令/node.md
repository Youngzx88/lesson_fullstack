## let

- 会有暂时性死区
- 连在 typeof 也不再安全

## 块级作用域

- 解决内层变量被外层覆盖的问题
- 块级作用于让 IIFE 变得不再必要
- ES5 规定，函数只能在`顶层作用域`和`函数作用域`之中声明,但浏览器还是支持块级作用域
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用
- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```js
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret'
  function f() {
    return a
  }
}
// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret'
  let f = function () {
    return a
  }
}
```

## const 命令

- 对于 const 来说，只声明不赋值，就会报错。
- const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。
- 同样存在暂时性死区
- const 表示的是指向的地址不可改变，但是值可以变化
- 如果真的想将对象冻结，应该使用 Object.freeze 方法。
  - 除了将对象本身冻结，对象的属性也应该冻结。

```js
const foo = Object.freeze({})
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123
```

-

## 顶层对象

- 顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象
- 顶层对象的属性与全局变量挂钩，被认为是 javascript 最大的败笔
- 所以 ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
- ES2020 在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。
