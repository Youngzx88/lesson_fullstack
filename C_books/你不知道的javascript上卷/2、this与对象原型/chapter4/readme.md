# 第四章、混合对象‘类’

### 4.1、类理论
- 由于类是一种`设计模式`，所以你可以用一些方法`近似实现`类的功能，为了满足`类设计模式`的普遍需求，js提供了一些`近似类`的语法
### 4.2、类的继承
1. `构造函数`：类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。
2. `类的继承`：js虽然不提供多继承，但是后续开发者会尝试使用各种办法实现多继承
3. `多态`：
    - 子类继承自父类的x方法，但是子类调用了`inherit: x()`方法，表明子类可以引用继承原来`x()`方法,这个技术被称为`多态`或者`虚拟多态`，更恰当的说法是`相对多态`
    - 我们所说的`相对`只是多态的一个方面，任何方法都可以引用继承层次中高层的方法(无论名字是否相同)
    - 之所以说相对,是因为我们并不会想要访问的绝对继承层次，而是使用相对引用，查找上一层
    - ES6中可以用super()解决
    - ps：父类和子类都有`x方法`，调用的时候，看是谁的`实例`，选择调用谁的`x方法`

- 继承的方式：
    - 1. 原型链继承
    - 2. 类式继承（借用构造函数）
    ```js
    function Parent(age) {
        this.name = ['mike', 'jack', 'smith'];
        this.age = age;
    }
    function Child(age) {
        //Parent.call(this, age);
        Parent.apply(this, [age]);
    }
    ```
    - 3. Class继承（ES6） extends
### 4.3、混入
- 在继承或实例化的时候，js对象机制并不会自动执行复制行为，而是混入，分为`显式混入`和`隐式混入`
#### 4.3.1、显式混入
- 手动遍历`源对象`和`新对象`,把源对象中的`属性`和`方法`复制到新对象当中
#### 4.3.2、隐式混入
- 在Another类中调用`Someing.cool.call(this)`
- 达到把something的行为混入another之中
#### 4.3.3、寄生继承
- 保留原有的，重写新的
#### 4.3.4、小结
- `多态`:看起来似乎是从子类引用父类，但是本质上引用其实是复制的结果
- `混入模式`:可以用来模拟类的复制行为，但是通常会产生丑陋且脆弱的语法，得不偿失