# 1.事件循环

## 渲染进程是什么？

- 渲染进程启动后，会开启一个渲染主线程，负责执行html，js，css等代码

- 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响

- 需要处理的任务：解析html、解析css、处理图层、每秒把页面画60次...

## 事件循环

- 在渲染主线程中有正在执行的`任务`
- 在消息队列中，有等待执行的任务，其他线程提供的任务会呗加入消息队列等待进入主线程执行
- 主线程最开始会进入无限循环，每次循环检查是否有其他任务，有则调用，没有就进入休眠状态
- 其他线程可以随时向消息队列中添加任务，主线程会从消息队列中取出任务，放入主线程中执行，如果主线程是休眠状态，会唤醒主线程
- 这样一来，就可以让每个任务有条不紊的运作，整个过程就叫做事件循环

## 什么是异步？

- setTimeout，网络通信
- 如果主线程等待这些耗时任务，那么就陷入阻塞了

## 任务有优先级吗？

- 任务没有优先级，在消息队列中先进先出
  - 但消息队列是有优先级的
  - 根据 W3C 的最新解释：
    - 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。
    - 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
    - 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行
    - 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法
- 在目前chrome 的实现中，至少包含了下面的队列：
  - 延时队列：用于存放计时器到达后的回调任务，优先级「中」
  - 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」
  - 微队列：用户存放需要最快执行的任务，优先级「最高」

- 添加任务到微队列的主要方式是使用：`Promise`,`MutationObservser`
  - Promise.resolve().then(函数)：函数直接进入微队列

- 解释2个例子，从1:24开始
