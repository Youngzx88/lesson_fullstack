# js

## 1、原型链

- Object -> Function -> 自定义函数
- 对开发的影响
  - 用instanceOf判断是不是真数组(例子)
  - Object.getProtoTypeOf(x):返回x对象的隐式原型(不常用)
  - 学会创建空原型对象
  - Object.setProtoTypeOf(obj,null):设置隐式原型为null;obj.\__proto__ = null

## 2、this指向

- 运行时候才知道this的指向
  - 通过new调用，指向新对象
  - 直接调用，指向全局对象
  - 通过对象调用，指向前面的对象  
  - call，apply，call的第一个参数，apply的第一个参数

## 3、标准库

- 略

## 4、webAPi

- BOM
  - window
  - setTimeout
  - ...
- DOM
  - 拿到dom，修改dom
  - 事件，事件的默认行为，传播机制
  - 事件委托：动态，大量；可以委托在父节点上

## 5、callback

## 6、正则

- 创建正则
  - new RegExp('规则','标识')
  - 规则
    - 匹配所有`var reg = /ab123/g`,匹配全文中所有ab123字符
    - 匹配其中一个`/[123]/i`,只会匹配123这个字符串中在被校验字符串中的其中一个，例如a1b2c3，匹配到1
    - 匹配所有字母`/[a-z]/gi`,`[a-zA-Z]/g`
    - 取非`/^[a-z]/g`非小写
    - \d,\D,\s,\S,\w,\W,^开始,$结束
    - 连续的规则(量词)
      - 一个数字紧跟一个字母`/\d[a-zA-Z]`
      - 规则出现几次`/(\d[a-zA-Z]){3}`
    - 匹配邮箱
  - 标识
    - i：ignore
    - g：global全局匹配
- 校验正则
  - reg.test('字符串)

## 7、解析html

- 读取html源代码
  - 遇到css或js停止解析，转去解析css或js
  - load和domContentLoaded
    - load需要所有资源全部加载完成才会被出发
    - domContentLoaded只要dom拿到就可以了
  - 浏览器一边生成dom树，一边计算dom树种每个节点的样式规则，最终形成渲染树
  - 进行布局重排：重排会集中更新，但是如果读取高度会导致强制重排
  - 进行重新绘制

## 7、异常

## 8、事件循环

### 8.1、浏览器的进程模型

- 浏览器是多进程，多线程的应用程序
- 浏览器进程
  - 负责界面显示，用户交互，子进程管理
- 网络进程
  - 负责加载网路瓯子永远
- 渲染进程(一个标签页一个渲染进程)，互相不影响
  - 渲染进程启动后，开始一个渲染主线程，主线程负责执行html，css，js代码
  - 默认情况下，浏览器会为每个标签开启一个新的渲染进程，保证不同标签页之前互不影响
  - 处理这么多任务，如何调度任务？排队

### 8.2、排队

- 渲染主线程：任务(正在执行的，从消息队列中拿的)
- 消息队列：任务、任务、任务
- 其他线程：任务例如点击事件(会被赛到消息队列)

### 8.3、过程

- 最开始的时候，渲染主进程会进入一个无限循环
- 每一次循环会检查消息队列是否有任务存在，如果有就取出第一个任务执行，执行完后进入下一次循环，没有进入休眠状态
- 其他所有线程，可随时想消息队列添加任务，新任务会加到消息队列的末尾，在添加新任务时，如果主线程是休眠状态

### 8.4、任务的优先级

- 任务没有优先级，但是消息队列有
- 同一种任务必须在一个消息队列，在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行
- 浏览器必须准备好一个微队列，微队列中的任务优先所有任务执行
- 目前chrome中实现
  - 延时队列：计时器
  - 交互队列：用户操作后产生的
  - 用户存放需要最快执行的任务：promise，MutationObserver