# JavaScript 权威指南

## 1、

## 2、

## 3、Js类型

- Number
- Text
- Boolean
  - 任何Js的值都能转化为布尔值
  - 所有其他值，包括所有对象（和数组）都转换为 true，并像 true 一样工作。
  - 假值，以及转换为假值的六个值`undefined，null，0，-0，NaN，""`，有时被称为假值，其他所有值都被称为真值。
  - 注意判断的时候如果使用`if(a)`需要知道自己是否需要区分`null 和 0 和 ""`,如果需要要显示判断
- null、undefined
  - null 表示一个"没有值"的值
  - typeOf null为Object
  - undefined 是尚未初始化的变量的值，以及在查询不存在的对象属性或数组元素的值时获得的值
  - typeOf undefined为undefined
  - 注意不要用`.`和`[]`去访问null和undefined,会导致typeError
- Symbols
  - 符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生冲突
  - Symbol() 函数接受一个可选的字符串实参，并返回一个唯一的符号值。
  - Symbol 是一种语言扩展机制。当 ES6 引入 for/of 循环时，它需要定义标准方法使类可以迭代。未来不会破坏现有的代码，所以使用了一个符号名称代替
- 全局对象
  - 在node中是global
  - 在浏览器中是window
- 原始值与对象的区别联系
  - 原始值：`undefined、null、布尔值、数字和字符串`不可改变
  - 原始值的比较是值的比较：只有在它们的值相等时它们才相等
  - 对象：可以改变，引用类型（reference type）
  - 对象的比较并非值的比较：即使两个对象包含同样的属性及相同的值，它们也是不相等的。各个索引元素完全相等的两个数组也不相等
  - 对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。
- 类型转换
  - 原始值转化为原始值遵循表：Value -> to String -> to Number -> to Boolean
  - 显示类型转换： Boolean()、Number() 和 String() 函数
  - 对象到原始值的转化(遵循对象的转化方式)
    - 1. 偏好字符串 `prefer-string` 如果可以转换成字符串，这个算法会返回一个原始值，提供一个字符串。
    - 2. 偏好数字 `prefer-number` 如果可以转换，这个算法会返回一个原始值，提供一个数字。
    - 3. 无偏好 `no-preference` 此算法表示不对任何类型原始值有偏好，并且可以定义自己的转换。在内置的 JavaScript 类型中，**除 Date 之外，其他所有类型都将此算法实现为偏好数字。Date 类将偏好字符串作为无偏好转换算法**。
    - 4. 对象到**布尔**的转换很简单：所有对象都转换为true。
    - 5. 当一个对象需要转换为**字符串**时，JavaScript 首先使用 prefer-string 算法将其转换为原始值，然后根据表 3-2 的规则将得到的原语值转换为字符串。
    - 6. 当一个对象需要转换为**数字**时，JavaScript首先使用prefer-number算法将其转换为一个原始值，然后根据表3-2的规则将结果原始值转换为数字
    - 7. `+` 运算符如果它的任意一个操作数是对象，JavaScript会使用无优先级算法将它们转换为原始值。一旦它有了两个原始值，它就检查它们的类型。如果其中一个实参是字符串，它将另一个实参转换为字符串并连接字符串。否则，它将两个实参都转换为数字并相加。
    - 8. `==和!=`运算符以一种允许类型转换的不严格方式执行相等和不相等的测试。如果一个操作数是对象，另一个是基元值，这些运算符使用无优先级算法将对象转换为基元值，然后比较两个基元值。
    - 9. `<、<=、>和>=`关系运算符比较其操作数的顺序，可用于比较数字和字符串。如果其中一个操作数是对象，则使用prefer-number算法将其转换为原始值。但是，请注意，与对象到数字的转换不同，preferred -number转换返回的原始值随后不会转换为数字。
    - 10. Date对象的数字表示可以与<和>进行有意义的比较，但字符串表示不能。对于Date对象，no-preference算法会转换为字符串，因此JavaScript对这些运算符使用prefer-number算法的事实意味着我们可以使用它们来比较两个Date对象的顺序。
    - 11. 所有对象都继承了两种用于对象到原语转换的转换方法
      - toString()，它的任务是返回对象的字符串表示`({x: 1, y: 2}).toString()    // => "[object Object]",[1,2,3].toString()// => "1,2,3"`
      - valueOf()它被假定将一个对象转换为表示该对象的原始值。对象是复合值，大多数对象不能真正用单个原始值表示，因此默认的valueOf()方法只是返回对象本身，而不是返回一个原始值。Date类定义了一个valueOf()方法，以其内部表示形式返回日期:`let d = new Date(2010, 0, 1);January 1, 2010, (Pacific time)d.valueOf() // => 1262332800000`
    - 12. 根据toString()和valueOf()的方法我们可以得到从对象到原语的算法是如何工作的
      - prefer-string算法首先尝试toString()方法。如果该方法被定义并返回一个原语值，那么JavaScript将使用该原语值(即使它不是字符串!)如果toString()不存在或者它返回一个对象，那么JavaScript会尝试valueOf()方法。如果该方法存在并返回一个原始值，那么JavaScript将使用该值。否则，转换将失败，并出现TypeError。
      - prefer-number算法的工作原理与prefer-string算法相似，不同之处是它首先尝试valueOf()，然后尝试toString()。
      - 无优先级算法取决于被转换对象的类。如果对象是Date对象，那么JavaScript使用prefer-string算法。对于任何其他对象，JavaScript都使用prefer-number算法。
- 解构语法(复合声明和赋值语法)
  - 1. 数组解构
  - 2. 对象解构
  - 如果你想在解构数组时将所有未使用的或剩余的值收集到一个变量中，在左边最后一个变量名之前使用三个点（…）： `let [x, ...y] = [1,2,3,4];  // y == [2,3,4]`
  - 给对象新值`const obj = {a: 1, b: {c: 2, d: 3, e: {f: 4}}};const updatedObj = {...obj,b: {...obj.b,e: {...obj.b.e,g: 1}}}`
`

## 4. 表达式和运算符
